/*  最长公共子序列
	题目：给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。
	示例：
			输入：
			A: [1,2,3,2,1]
			B: [3,2,1,4,7]
			输出：3
			解释：
			长度最长的公共子数组是 [3, 2, 1] 。
	提示：
			1 <= len(A), len(B) <= 1000
			0 <= A[i], B[i] < 100
	思路：用dp[i][j]记录每次A[i-1]==B[j-1]的长度，若A[i - 1] == B[j - 1],则dp[i][j] = dp[i - 1][j - 1] + 1，再用Max记录最大
		  长度，Max = Max > dp[i][j] ? Max : dp[i][j]。具体可以看示例，当A[3-1]==B[1-1],则dp[3][1]=dp[2][0]+1,由于第一行
		  和第一列始终为0，dp[3][1]=1;继续遍历，当A[4-1]==B[2-1],则dp[4][2]=dp[3][1]+1，即dp[4][2]=2，当A[5-1]==B[3-1],
		  则dp[5][3]=dp[4][2]+1,即dp[5][3]=3。基本原理就是用一个ASize*BSize的二维数组,来作为记录A[i]==B[j]时的表，由于
		  每次我们要用到dp[i][j] = dp[i - 1][j - 1] + 1，导致第一排第一列完全用不到，故我们需要一个(ASize+1)*(BSize+1)的
		  二维数组，每次在记录当前数据时，记得要加上左上角表中的数据，即看A中左边一位和B中右边一位是否相等，若相等，那此时
		  左上角记录的应为1，这是再加上当前的，即为2，如此下去。
	总结：在几次提交中，显示“0x00291929 处有未经处理的异常(在 最长公共子序列.exe 中): 0xC00000FD: Stack overflow 
		  (参数: 0x00000000, 0x00802000)”，网上查阅了一下，原因是数组定义的太大，我开始定义的数组是dp[1001][1001]。
*/

#include<stdio.h>
#define M 5
#define N 5
int findLength(int* A, int ASize, int* B, int BSize) {
	int dp[M + 1][N + 1] = { 0 };
	int i, j, Max = 0;
	for (i = 1; i < ASize + 1; i++)
		for (j = 1; j < BSize + 1; j++) {
			if (A[i - 1] == B[j - 1]) {
				dp[i][j] = dp[i - 1][j - 1] + 1;
				Max = Max > dp[i][j] ? Max : dp[i][j];
			}
			else
				dp[i][j] = 0;
		}
	return Max;
}
int main(void) {
	int A[M] = { 1,2,3,2,1 };
	int B[N] = { 3,2,1,4,7 };
	int res = findLength(A, M, B, N);
	printf("%d", res);
}
